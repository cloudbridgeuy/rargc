use std::fs;

use color_eyre::eyre::Result;

use crate::script::Script;

pub struct Command {
    options: Options,
}

pub struct Options {
    pub script_root: String,
}

impl Command {
    /// Create a new command
    pub fn new(options: Options) -> Self {
        Self { options }
    }

    /// Run the command
    pub fn run(&self) -> Result<()> {
        let source = fs::read_to_string(&self.options.script_root)
            .unwrap_or_else(|_| panic!("Unable to read file: {}", &self.options.script_root));

        let script = Script::from_source(&source)?;

        let output = format!(
            r#"
{}
# This script was generated by rargc 0.0.1 (https://rargc.cloudbridge.uy)
# Modifying it directly is not recommended.

if [[ "${{BASH_VERSINFO[0]}}" -lt 4 ]]; then
    echo "This script requires Bash 4 or higher."
    exit 1 \
fi

{}

{}"#,
            script.shebang,
            format_version(&script),
            format_cli_usage(&script),
        );

        println!("{}", output);

        Ok(())
    }
}

/// Formats the version command for the script.
fn format_version(script: &Script) -> String {
    if let Some(version) = &script.version {
        format!(
            r#"## Version command
version_command() {{
    echo "{}"
}}"#,
            version
        )
    } else {
        "".to_string()
    }
}

/// Formats the CLI usage for the script.
fn format_cli_usage(script: &Script) -> String {
    format!(
        r#"## CLI usage
cli_usage() {{
    printf "{}\n\n"
    printf "USAGE:\n"
    printf "   {}\n"
    printf "   {}\n"
    printf "   {}\n"
}}"#,
        format_cli_description(script),
        format_cli_usage_string(script),
        format_cli_usage_help_string(script),
        format_cli_usage_version_string(script),
    )
}

/// Formats the CLI Descripton
fn format_cli_description(script: &Script) -> String {
    if let Some(name) = &script.meta.name {
        if let Some(description) = &script.meta.description {
            format!("{} - {}", name, description)
        } else {
            name.to_string()
        }
    } else {
        "$0".to_string()
    }
}

/// Formats the CLI Usage String
fn format_cli_usage_string(script: &Script) -> String {
    let name = script
        .meta
        .name
        .to_owned()
        .unwrap_or_else(|| "$0".to_string());
    let has_commands = !script.commands.is_empty();

    if has_commands {
        format!("{} [COMMAND] [OPTIONS] [ARGS]", name)
    } else {
        format!("{} [OPTIONS] [ARGS]", name)
    }
}

/// Formats the CLI Usage Help String
fn format_cli_usage_help_string(script: &Script) -> String {
    let name = script
        .meta
        .name
        .to_owned()
        .unwrap_or_else(|| "$0".to_string());
    let has_commands = !script.commands.is_empty();

    if has_commands {
        format!("{} [COMMAND] --help | -h", name)
    } else {
        format!("{} --help | -h", name)
    }
}

/// Formats the CLI Usage Version String
fn format_cli_usage_version_string(script: &Script) -> String {
    let name = script
        .meta
        .name
        .to_owned()
        .unwrap_or_else(|| "$0".to_string());

    format!("{} --version | -v", name)
}
